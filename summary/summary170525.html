<!DOCTYPE html>
<html>

	<head>
		<title>总结</title>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				width: 1000px;
				margin: 0px auto;
				background-image: url(images/12.jpg);
			}
			
			h1 {
				color: tomato;
			}
			
			h2,
			h3 {
				color: blue;
			}
			
			p {
				font-size: 14px;
				color: #9932CC;
				margin-left: 60px;
				text-indent: 30px;
				font-weight: 1000;		
			}
			
			strong{
				color: #5F9EA0;
				
				font-weight: bold;
			}
			b {
				color: chocolate;
				font-style: italic;
				font-weight: bold;
			}
			
			.Big a {
				font-size: 20px;
				color: #9932CC;
			}
			
			img {
				width: 350px;
				height: 100px;
				margin: 10px 0px 10px 20px;
			}
			
			ol {
				counter-reset: li;
				/* 创建一个计数器 */
				list-style: none;
				/* 清除列表默认的编码*/
				*list-style: decimal;
				/* 让IE6/7具有默认的编码 */
				font: 15px 'trebuchet MS', 'lucida sans', '微软雅黑', sans-serif;
				padding: 10px 0px 10px 10px;
				margin-bottom: 4em;
				text-shadow: 0 1px 0 rgba(255, 255, 255, .5);
			}
			
			ol ol {
				margin: 0 0 0 2em;
				/* 给二级列表增加一定的左边距*/
				counter-reset: list;
			}
			
			ol ol ol {
				margin: 0 0 0 2em;
				/* 给三级列表增加一定的左边距*/
				counter-reset: listt;
			}
			
			.rectangle-list a {
				position: relative;
				display: block;
				padding: .4em .4em .4em .8em;
				*padding: .4em;
				margin: .5em 0 .5em 2.5em;
				background: #ddd;
				color: #444;
				text-decoration: none;
				transition: all .3s ease-out;
			}
			
			.rectangle-list a:hover {
				background: #eee;
			}
			
			.rectangle-list a:before {
				content: counter(li);
				counter-increment: li;
				position: absolute;
				left: -2.5em;
				top: 50%;
				margin-top: -1em;
				background: #fa8072;
				height: 2em;
				width: 2em;
				line-height: 2em;
				text-align: center;
				font-weight: bold;
			}
			
			.rectangle-list a:after {
				position: absolute;
				content: '';
				border: .5em solid transparent;
				left: -1em;
				top: 50%;
				margin-top: -.5em;
				transition: all .3s ease-out;
			}
			
			.rectangle-list a:hover:after {
				left: -.5em;
				border-left-color: #fa8072;
			}
			
			.rounded-list a {
				position: relative;
				display: block;
				padding: .4em .4em .4em 2em;
				*padding: .4em;
				margin: .5em 0;
				background: #ddd;
				color: #444;
				text-decoration: none;
				border-radius: .3em;
				transition: all .3s ease-out;
			}
			
			.rounded-list a:hover {
				background: #eee;
			}
			
			.rounded-list a:hover:before {
				transform: rotate(360deg);
			}
			
			.rounded-list a:before {
				content: counter(li)"."counter(list);
				counter-increment: list;
				position: absolute;
				left: -1.3em;
				top: 50%;
				margin-top: -1.3em;
				background: #87ceeb;
				height: 2em;
				width: 2em;
				line-height: 2em;
				border: .3em solid #fff;
				text-align: center;
				font-weight: bold;
				border-radius: 2em;
				transition: all .3s ease-out;
			}
			
			.rounded-list1 a:hover:after {
				left: -1.5em;
				border-left-color: #fff;
			}
			
			.rounded-list a:hover:after {
				left: -1.5em;
				border-left-color: #fff;
			}
			
			.rounded-list1 a:before {
				content: counter(li)"."counter(list)"."counter(listt);
				counter-increment: listt;
				position: absolute;
				left: -1.3em;
				top: 50%;
				margin-top: -1.3em;
				background: #87ceeb;
				height: 2.5em;
				width: 2.5em;
				line-height: 2.5em;
				border: .3em solid #fff;
				text-align: center;
				font-weight: bold;
				border-radius: 2em;
				transition: all .3s ease-out;
				font-size: 12px;
			}
		</style>
	</head>

	<body>
		<div id="demon">
			<h2>ECMAScript6、NODE.JS</h2>
			<ol class="rectangle-list">
				<li class="Big">
					<a href="javascript:;">ECMAScript6</a><br />
				</li>
				<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
				<ol class="rounded-list">
					<li>
						<a href="javascript:;">
							<b>let命令</b><br/>
							ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
						</a>
							<ol class="rounded-list1">
								<li>
									<a href="javascript:;"> 
									    <strong>
									    	{<br/>
											  let a = 10;<br/>
											  var b = 1;<br/>
											}<br/>
											a // <b>ReferenceError: a is not defined.</b><br/>
											b // <b>1</b><br/>
									    </strong>
									    <b>注意</b>:上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，<b>结果let声明的变量报错</b>，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。
								    </a>
								</li>
								<li>
									<a href="javascript:;">
									    <b>不存在变量提升</b><br/>
									    ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。<br />
									    <strong>
									    	// var 的情况<br/>
											console.log(foo); // 输出<b>undefined</b><br/>
											var foo = 2;<br/>
											// let 的情况<br/>
											console.log(bar); // 报错<b>ReferenceError</b><br/>
											let bar = 2;<br/>
									    </strong>
									    <b>注意</b>:var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。
为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。
								    </a>
								</li>
								<li>
									<a href="javascript:;">
									    <b>不允许重复声明</b><br/>
									    ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。<br />
									    <strong>
									    	// 报错<br/>
											function () {<br/>
											  let a = 10;<br/>
											  let a = 1;<br/>
											}<br/>
											// 报错<br/>
											function () {<br/>
											  let a = 10;<br/>
											  var a = 1;<br/>
											}<br/>
											function func(arg) {<br/>
											  let arg; //<b> 报错</b><br/>
											}<br/>
											function func(arg) {<br/>
											  {<br/>
											    let arg; // <b>不报错</b><br/>
											  }<br/>
											}<br/>
									    </strong>
									    <b>注意</b>:let不允许在相同作用域内，重复声明同一个变量。
								    </a>
								</li>
								<li>
									<a href="javascript:;">
									    <b>ES6 的块级作用域</b><br/>
									    let实际上为 JavaScript 新增了块级作用域。<br />
									    <strong>
									    	function f1() {<br />
											  let n = 5;<br />
											  if (true) {<br />
											    let n = 10;<br />
											  }<br />
											  console.log(n); // <b>5</b><br />
											}<br />
									    </strong>
									    <b>注意</b>:上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。
								    </a>
								</li>
							</ol>
					</li>
					<li>
						<a href="javascript:;">
							<b>const 命令 </b><br/>
							const声明一个只读的常量。一旦声明，常量的值就不能改变。
						</a>
						<ol class="rounded-list1">
							<li>
								<a href="javascript:;">
									    <strong><b></b>
									    	const PI = 3.1415;<br/>
											PI //<b>3.1415</b> <br/>
											PI = 3;<br/>
											// <b>TypeError: Assignment to constant variable.</b><br/>
									    </strong>
									    <b>注意</b>:上面代码表明改变常量的值会报错.<b>const</b>声明的变量不得改变值，这意味着，<b>const</b>一旦声明变量，就必须立即初始化，不能留到以后赋值。
							    </a>
							</li>
							<li>
								<a href="javascript:;">
									<b>const本质</b><br/>
									    const实际上保证的，并不是变量的值不得改动，而是<b>变量指向的那个内存地址不得改动。</b>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<b>const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</b>因此，将一个对象声明为常量必须非常小心。<br />
									    <strong>
									    	const foo = {};<br/>
											// 为 foo 添加一个属性，可以成功<br/>
											foo.prop = 123;<br/>
											foo.prop // <b>123</b><br/>
											// 将 foo 指向另一个对象，就会报错<br/>
											foo = {}; // <b>TypeError: "foo" is read-only</b><br/>
									    </strong>
									    <b>注意</b>:上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
							    </a>
							</li>
						</ol>
						<li>
								<a href="javascript:;">
									<b>箭头函数</b><br/><strong></strong>
									   1.ES6允许使用“箭头”<b>（=>）</b>定义函数。<br />
									   &nbsp;&nbsp;&nbsp;&nbsp;<strong>var f = v => v;</strong><b>等同于</b><strong>var f = function(v) {return v;};</strong><br />
									   2.如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。<br />	
                                          &nbsp;&nbsp;&nbsp;&nbsp;<strong>var f = () => 5; </strong><b>等同于</b><strong>var f = function () { return 5 };</strong><br />	
									      &nbsp;&nbsp;&nbsp;&nbsp;<strong>var sum = (num1, num2) => num1 + num2; </strong><b>等同于</b><strong>var sum = function(num1, num2) { return num1 + num2;};</strong><br />	
							           3.如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。<br />
							             &nbsp;&nbsp;&nbsp;&nbsp;<strong>var sum = (num1, num2) => { return num1 + num2; }</strong><br />
							           4.由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 <br />	
							             &nbsp;&nbsp;&nbsp;&nbsp;<strong>var getTempItem = id => ({ id: id, name: "Temp" });</strong><br />
                                       5.<b>注意事项</b>:<br />
                                                                        （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。this对象的指向是可变的，但是在箭头函数中，它是固定的。<br />
                                                                        （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br />
										（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。<br />
										（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。<br />
										<strong>
											example:<br />
											&nbsp;&nbsp;&nbsp;&nbsp;function foo() {<br />
											  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() => {<br />
											    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('id:', this.id);<br />
											 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }, 100);<br />
											&nbsp;&nbsp;&nbsp;&nbsp;}<br />
											&nbsp;&nbsp;&nbsp;&nbsp;var id = 21;<br />
											&nbsp;&nbsp;&nbsp;&nbsp;foo.call({ id: 42 });<br />
											&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<b> id: 42</b><br />
										</strong>
										<b>解析</b>:上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。
								</a>
							    
							</li>
				</ol>

				<li class="Big">
					<a href="javascript:;">Node.js</a>
				</li>
				<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
				<ol class="rounded-list">
					<li>
						<a href="javascript:;">
					Node.js 创建第一个应用：<br/>
	                     1.引入 required 模块<br/>
	                     我们使用 <b>require</b> 指令来载入 <b>http 模块</b>，并将实例化的 HTTP 赋值给变量 http，实例如下: <br/>
	                     &nbsp;&nbsp;&nbsp;&nbsp;<strong>var http = require("http");</strong><br/>
	                     2.创建服务器<br/>
	                     接下来我们使用  <b>http.createServer() </b>方法创建服务器，并使用  <b>listen</b> 方法绑定 8888 端口。 函数通过  <b>request</b>,  <b>response</b> 参数来接收和响应数据。<br/>
	                     <strong>var http = require('http');<br/>
								http.createServer(function (request, response) {<br/></strong>
									// 发送 HTTP 头部 <br/>
									// HTTP 状态值: 200 : OK<br/>
									// 内容类型: text/plain<br/>
									<strong>response.writeHead(200, {'Content-Type': 'text/plain'});</strong><br/>
									// 发送响应数据 "Hello World"<br/>
									<strong>response.end('Hello World\n');<br/>
								}).listen(8888);</strong><br/>
								// 终端打印如下信息<br/>
								<strong>console.log('Server running at http://127.0.0.1:8888/');</strong><br/>
						  3.使用 <b> 命令执行以上的代码</b>：<br/>
						    <strong>node server.js<br/>
							Server running at http://127.0.0.1:8888/</strong>
							</a>
						</li>
						
				</ol>
			</ol>

		</div>

	</body>

</html>